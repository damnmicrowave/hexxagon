{"version":3,"sources":["components/board/Board.module.scss","components/utils.ts","components/cell/Cell.tsx","components/board/Board.tsx","components/header/Header.tsx","app/App.tsx","reportWebVitals.ts","index.tsx","components/cell/Cell.module.scss","components/header/Header.module.scss"],"names":["module","exports","getCell","game","cell","coords","grid","q","r","hexDirections","getHexDistance","cell1","cell2","Math","abs","Cell","props","useContext","GameContext","cellBox","useRef","onHover","useCallback","e","current","hexBoundingRect","x","y","left","top","width","height","hexCenterX","hexCenterY","h","v","quadrantX","quadrantY","isInsideHex","clientX","clientY","getBoundingClientRect","classList","contains","styles","currentPlayer","highlighted","remove","hovered","add","useEffect","window","addEventListener","removeEventListener","state","highlightColor","ref","className","classnames","onClick","makeMove","selectCell","style","hexagonBox","hexagon","backgroundColor","highlighting","Board","board","Object","values","map","Header","header","generateEmptyGrid","halfWidth","forEach","index","q_dir","r_dir","createContext","App","initialGameState","targetCell","setGame","prevGameState","newGameState","c","selectedCell","undefined","useState","getWinner","blackCells","filter","whiteCells","emptyCells","allCells","length","every","n","winner","alert","location","reload","Provider","value","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.29c81d3f.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"board\":\"Board_board__1FVup\"};","import { Cell, Game } from './types'\n\n// this function checks if given coordinates are inside a hexagon\nexport const isInsideHex = (coords: number[], hexBoundingRect: DOMRect) => {\n  const [x, y] = coords\n\n  // get hexagon's bounding rectangle position offsets, width and height\n  const { left, top, width, height } = hexBoundingRect\n  // calculate hexagon's center coordinates\n  const hexCenterX = width / 2 + left\n  const hexCenterY = height / 2 + top\n\n  // use the formula from this article: http://www.playchilla.com/how-to-check-if-a-point-is-inside-a-hexagon\n  const [h, v] = [width / 2, height / 4]\n\n  const quadrantX = Math.abs(x - hexCenterX)\n  const quadrantY = Math.abs(y - hexCenterY)\n\n  if (quadrantX > h || quadrantY > v * 2) return false\n  return 2 * v * h - v * quadrantX - h * quadrantY >= 0\n}\n\n// returns true if cells' coordinates are the same\nexport const cellsMatch = (cell1: Cell, cell2: Cell) =>\n  cell1.r === cell2.r && cell1.q === cell2.q\n\nexport const getCell = (\n  game: Game,\n  cell?: Cell,\n  coords?: { q: number; r: number }\n) => {\n  if (coords) {\n    return game.grid[`${coords.q}${coords.r}`]\n  }\n  return game.grid[`${cell?.q}${cell?.r}`]\n}\n\n// these are six axial directions, see this: https://www.redblobgames.com/grids/hexagons/#neighbors-axial\nexport const hexDirections = [\n  [1, 0],\n  [1, -1],\n  [0, -1],\n  [-1, 0],\n  [-1, 1],\n  [0, 1]\n]\n\n// this returns distance between two cells, see this: https://www.redblobgames.com/grids/hexagons/#distances-axial\nexport const getHexDistance = (cell1: Cell, cell2: Cell) =>\n  (Math.abs(cell1.q - cell2.q) +\n    Math.abs(cell1.q + cell1.r - cell2.q - cell2.r) +\n    Math.abs(cell1.r - cell2.r)) /\n  2\n","import React, { useCallback, useContext, useEffect, useRef } from 'react'\nimport classnames from 'classnames'\nimport { isInsideHex } from '../utils'\nimport { GameContext } from 'app/App'\nimport { Cell as CellProps } from '../types'\n\nimport styles from './Cell.module.scss'\n\nexport const Cell = (props: CellProps) => {\n  const game = useContext(GameContext)\n\n  const cellBox = useRef<HTMLDivElement>(null)\n  // this function adds 'hovered' class to the cell if it's being hovered with a mouse\n  const onHover = useCallback(\n    (e: MouseEvent) => {\n      const cell = cellBox.current\n      if (!cell) return\n\n      const mouseCoords = [e.clientX, e.clientY]\n      const cellBoundingRect = cell.getBoundingClientRect()\n      if (\n        isInsideHex(mouseCoords, cellBoundingRect) &&\n        (cell.classList.contains(styles[game.currentPlayer]) ||\n          cell.classList.contains(styles.highlighted))\n      ) {\n        cell.classList.add(styles.hovered)\n      } else {\n        cell.classList.remove(styles.hovered)\n      }\n    },\n    [game.currentPlayer]\n  )\n\n  useEffect(() => {\n    // here we tell js to run our onHover function every time we move the cursor\n    // this is also called \"event listener\"\n    window.addEventListener('mousemove', onHover)\n    // we also call onHover on every turn\n\n    // remove event listener when component gets unmounted (it's a good practise)\n    return () => window.removeEventListener('mousemove', onHover)\n  }, [onHover])\n\n  const { q, r, state, highlighted, highlightColor } = props\n  return (\n    <div\n      ref={cellBox}\n      className={classnames(styles.cellBox, styles[state], {\n        [styles.highlighted]: highlighted\n      })}\n      onClick={() => {\n        if (highlighted) {\n          game.makeMove(props)\n        } else {\n          game.selectCell(props)\n        }\n      }}\n      style={\n        {\n          '--q': q,\n          '--r': r\n        } as React.CSSProperties // without this TypeScript won't allow setting css-variables\n      }\n    >\n      <div className={styles.hexagonBox}>\n        <div className={styles.hexagon} />\n        {highlighted && (\n          <div\n            style={{ backgroundColor: highlightColor }}\n            className={styles.highlighting}\n          />\n        )}\n      </div>\n    </div>\n  )\n}\n","import { Cell } from 'components'\nimport { CellsGrid } from '../types'\n\nimport styles from './Board.module.scss'\n\nexport const Board = (props: { grid: CellsGrid }) => {\n  return (\n    <div className={styles.board}>\n      {Object.values(props.grid).map(cell => (\n        // {...cell} is a shorthand for q={cell.q} r={cell.r} state={cell.state} etc...\n        <Cell key={`${cell.q}${cell.r}`} {...cell} />\n      ))}\n    </div>\n  )\n}\n","import classnames from 'classnames'\nimport { Player } from '../types'\n\nimport styles from './Header.module.scss'\n\nexport const Header = (props: { currentPlayer: Player }) => {\n  return (\n    <div className={classnames(styles.header, styles[props.currentPlayer])}>\n      HEXXAGON\n    </div>\n  )\n}\n","import { createContext, useCallback, useEffect, useState } from 'react'\nimport { Board, Header } from 'components'\nimport {\n  cellsMatch,\n  getCell,\n  getHexDistance,\n  hexDirections\n} from 'components/utils'\nimport { Cell, CellsGrid, Game, Player } from 'components/types'\n\nimport './App.scss'\n\nconst generateEmptyGrid = (width: number): CellsGrid => {\n  const grid: CellsGrid = {}\n\n  // ~~ is a shorthand for Math.floor()\n  const halfWidth = ~~(width / 2)\n\n  // e.g. if grid width is 7, we iterate from -3 to 3\n  for (let q = -halfWidth; q <= halfWidth; q++) {\n    for (let r = -halfWidth; r <= halfWidth; r++) {\n      // this ensures that all the cells are within halfSize radius from the center cell\n      if (Math.abs(q + r) <= halfWidth) {\n        grid[`${q}${r}`] = {\n          q,\n          r,\n          highlighted: false,\n          state: 'empty'\n        }\n      }\n    }\n  }\n\n  // put initial states on the corners\n  hexDirections.forEach(([q_dir, r_dir], index) => {\n    grid[`${halfWidth * q_dir}${halfWidth * r_dir}`].state =\n      index % 2 === 0 ? 'white' : 'black'\n  })\n\n  // remove 3 center cells\n  delete grid['0-1']\n  delete grid['10']\n  delete grid['-11']\n  return grid\n}\n\nexport const GameContext = createContext<Game>({\n  grid: {},\n  currentPlayer: 'white',\n  makeMove: () => {},\n  selectCell: () => {}\n})\n\nexport const App = () => {\n  const makeMove = (targetCell: Cell) => {\n    setGame(prevGameState => {\n      const newGameState = { ...prevGameState }\n\n      const cell = getCell(game, targetCell)\n      cell.state = newGameState.currentPlayer\n\n      // remove highlighting from all cells\n      Object.values(newGameState.grid).forEach(c => {\n        c.highlighted = false\n      })\n\n      // convert all opponent's neighbour cells into current player's color\n      Object.values(newGameState.grid).forEach(c => {\n        if (\n          getHexDistance(cell, c) === 1 &&\n          c.state !== 'empty' &&\n          c.state !== newGameState.currentPlayer\n        ) {\n          c.state = newGameState.currentPlayer\n        }\n      })\n\n      // clear selected cell if target cell isn't its neighbour\n      if (\n        newGameState.selectedCell &&\n        getHexDistance(newGameState.selectedCell, cell) !== 1\n      ) {\n        getCell(game, newGameState.selectedCell).state = 'empty'\n      }\n\n      // change current player\n      newGameState.currentPlayer =\n        newGameState.currentPlayer === 'white' ? 'black' : 'white'\n\n      return newGameState\n    })\n  }\n  const selectCell = (cell: Cell) => {\n    setGame(prevGameState => {\n      const newGameState = { ...prevGameState }\n\n      // select the cell\n      newGameState.selectedCell =\n        // we deselect cell if it is already selected\n        newGameState.selectedCell && cellsMatch(newGameState.selectedCell, cell)\n          ? undefined\n          : cell\n\n      // remove highlighting from all cells\n      Object.values(newGameState.grid).forEach(c => {\n        c.highlighted = false\n      })\n\n      if (newGameState.selectedCell) {\n        // highlight neighbour cells if cell is selected\n        Object.values(newGameState.grid).forEach(c => {\n          if (getHexDistance(cell, c) === 1 && c.state === 'empty') {\n            c.highlighted = true\n            c.highlightColor = '#00ff00'\n            // highlight next row of cells\n          } else if (getHexDistance(cell, c) === 2 && c.state === 'empty') {\n            c.highlighted = true\n            c.highlightColor = '#ffff00'\n          }\n        })\n      }\n\n      return newGameState\n    })\n  }\n\n  const initialGameState = {\n    grid: generateEmptyGrid(9),\n    currentPlayer: 'white' as Player,\n    makeMove,\n    selectCell\n  }\n  const [game, setGame] = useState<Game>(initialGameState)\n\n  const getWinner: () => Player | null = useCallback(() => {\n    const blackCells = Object.values(game.grid).filter(c => c.state === 'black')\n    const whiteCells = Object.values(game.grid).filter(c => c.state === 'white')\n    const emptyCells = Object.values(game.grid).filter(c => c.state === 'empty')\n    const allCells = Object.values(game.grid)\n\n    // if no cells of one player left\n    if (!blackCells.length) return 'white'\n    if (!whiteCells.length) return 'black'\n\n    // if current player doesn't have any more moves\n    if (\n      emptyCells.every(e => {\n        const neighbours = allCells.filter(c => getHexDistance(e, c) <= 2)\n        return neighbours.every(n => n.state !== game.currentPlayer)\n      })\n    )\n      return blackCells.length > whiteCells.length ? 'black' : 'white'\n\n    return null\n  }, [game])\n\n  useEffect(() => {\n    const winner = getWinner()\n    if (winner) {\n      alert(`${winner} wins !`)\n      window.location.reload()\n    }\n  }, [getWinner])\n\n  return (\n    <GameContext.Provider value={game}>\n      <Header currentPlayer={game.currentPlayer} />\n      <Board grid={game.grid} />\n    </GameContext.Provider>\n  )\n}\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport { App } from 'app/App'\nimport reportWebVitals from './reportWebVitals'\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals()\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"cellBox\":\"Cell_cellBox__2Plcb\",\"hovered\":\"Cell_hovered__2H7x8\",\"empty\":\"Cell_empty__agmQX\",\"highlighted\":\"Cell_highlighted__1df4d\",\"hexagon\":\"Cell_hexagon__3UWhu\",\"hexagonBox\":\"Cell_hexagonBox__2HdQL\",\"highlighting\":\"Cell_highlighting__25vgi\",\"white\":\"Cell_white__2kwCy\",\"black\":\"Cell_black__1hpf_\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"header\":\"Header_header__1fCsm\",\"white\":\"Header_white__1rXBj\",\"black\":\"Header_black__2j6w4\"};"],"sourceRoot":""}